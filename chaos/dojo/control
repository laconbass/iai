#!/usr/bin/env /bin/bash

##
# Meta info about this script
# ---------------------------
# Variables defined below are meant to ease this script's reusability.
# TODO maybe use [dynamic variable names](http://stackoverflow.com/a/18124325/1894803)
# LIKE declare "$(basename "$0")_name"="$(basename "${BASH_SOURCE[0]}")"
# {declare} 
declare script_absolute="${BASH_SOURCE[0]}"
declare script_basename="$(basename "${meta[absolute]}")"
declare script_location="${BASH_SOURCE[0]}"

declare script_action="$(basename "$script_abpath")"
declare script_domain="development services"
declare script_parent="development services"

# TODOdeclare -p; exit 1

# repository's root directory
git_top="$(git rev-parse --show-toplevel)"
DIR="$( cd "$( dirname "$BASH_SOURCE" )" && pwd )"

##
# log utilities for this script
# -----------------------------
# logs a message ($") to stderr with desired level mark ($2 or ??)
log () { echo >&2 "(${2:-??}):" "$1"; }
# follows each input line to 'log' with desired level mark ($1)
loog () { while read line; do log "$line" "$1"; done < <(cat); }
# logs messages with an error level mark (EE)
emsg () { if (($#)); then log "$@" EE; else <0 loog; fi; }
# logs messages with an info level mark (II)
info () { if (($#)); then log "$@" II; else <0 loog; fi; }
# logs messages with a verbose level mark (VV)
verb () { if (($#)); then log "$@" VV; else <0 loog; fi; }
# helper to [fail fast](http://www.martinfowler.com/ieeeSoftware/failFast.pdf)
fail () { emsg "$@"; exit ${ERR:1}; }

WORK_LVL=0
wmsg () { printf "%$WORK_LVL.s" ">"; echo $1 ${WORK_NOW:?not working} $3; }
working () {
	WORK_NOW="${1:?missing description}"
	# TODO set traps!
	info $(wmsg "Will" "..."); SECONDS=0
}
workend () {
	code=$?; (( code )) && {
	  emsg $(wmsg "Fail" "after ${SECONDS}s:")
	  fail "at $(caller 1) \$? was $code"
    }
	info "Done $WORK_NOW.";	unset WORK_NOW; ((--WORK_LVL))
}

##
# Credits

service_control () {
	local action="control--${1:?"action is mandatory, try '$0 help'"}"
	test "$(type -t $action)" == "function" && shift && $action "$@" || {
   	  control--help
	  verb "action $action not found"
	  fail "bad argument list: $@"
    }
	# implicit return $?
}

##
# Displays a quick reference about this script.
# Searches [function names](http://gnu.org/software/bash/manual/bashref)
control--help () {
	while read keyword type fn; do
		[[ "$fn" =~ ^control--[a-Z]{2,}$ ]] && echo "$fn"
	done < <( declare -F )
	echo "Usage: $0 $(\
	  declare -F | grep -P ^control-- | while read a b fname; do
	    printf '%s|' "$( sed 's/^control--//' <<<$fname )"
	  done
	)]"
	return 0
}

control--find () {
echo "$script_absdir"
  for file in $(find "$script_absdir" -name '[0-9][0-9][0-9][0-9]-*'); do
	  echo "found $file"
	  printf "%d %s\n" "${file:0:3}" "${file:5}"
  done
}

##
# service management

service_start () {
	fail "$FUNCNAME: not implemented"
	local pid=$! name="${1:?service name is mandatory}"
	echo "$pid" > "$(pidfile "$name")"
	echo "$name service deployed with pid $pid"
}

status_up="running"
status_ko="stopped"

service_status () {
	fail "$FUNCNAME: not implemented"
	local name="${1:?service name is mandatory}"
	local pid="$(cat "$(pidfile $name)" 2>/dev/null)"
	(( pid ))\
		&& { echo "$name is $status_up with pid $pid"; return $true; }\
		|| { echo "$name is $status_ko"; return $false; }
}

service_stop () {
	fail "$FUNCNAME: not implemented"
	local name="${1:?service name is mandatory}"
	service_status "$name" >/dev/null || return $false
	local pid="$(cat "$(pidfile $name)" 2>/dev/null)"
	kill $pid && wait $pid && rm "$(pidfile "$name")" || return $false
	# TODO if pid does not exist
}

##
# Main script actions
#

start_services () {
	echo "Starting development services ... "
	fail "$FUNCNAME: not implemented"
}

status_services () {
	echo "Requesting development services status ... "
	fail "$FUNCNAME: not implemented"
	local c=0
	echo -n " + "; service_status "http-server"; (( c+=$? ))
	echo -n " + "; service_status "ws-proxy"; (( c+=$? ))
	return $c
}

stop_services () {
	echo "Stopping development services ... "
	fail "$FUNCNAME: not implemented"
	local name="http-server"
	echo -n " + Stop $name ... "; service_stop "$name"; echo "done."
	local name="ws-proxy"
	echo -n " + Stop $name ... "; service_stop "$name"; echo "done."
}

restart_services () {
	echo "Restarting development services ... "
	fail "$FUNCNAME: not implemented"
}


# TODO if not being sourced!
service_control "$@"

##
# vim modeline
# /* vim: set filetype=sh ts=4 shiftwidth=4: */
