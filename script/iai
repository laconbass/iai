#!/bin/bash

# NOTE: `set -e` impedes try-catching commands

##
# SCRIPT DEPENDENCIES
# ===================
# - seems lighter not sourcing until something is need
# - an error may happen when the path can't be sourced 
# - should depend only on bashido?
##

iai-dependencies () {
	type -t bashido >/dev/null || { echo >&2 "FATAL: missing bashido"; exit 1; }
	source "$(bashido abc-call_trace)" || exit
	source "$(bashido abc-log)" || exit
	source "$(bashido assert-basic)" || exit
	logs () {
		return 0 # uncomment this line for max amount of verbosity
		#echo "logs $@"
		test "$2" != "iai"
	}
	iai-dependencies () { true; }
  info "loaded iai dependencies"
}

##
# MAIN COMMAND
# ============
# `iai` acts as an accessor to sub-commands.
# When it's run without arguments, outputs some ascii art.
##
iai () {
  if test $# -eq 0
	then
		cat "$(iai-path db artii 0110)"
    exit 0
	fi

	type -t verb >/dev/null && verb "running 'iai-$@' (from $(caller))"

	local cmd="iai-$1"
	local typ="$(type -t "$cmd")"

	if test "$typ" != "function"; then
		# when cmd is function, it's either builtin or an already sourced file
		iai-dependencies || exit
		# when command is a file, it's assumed to be its function source file
		if test "$typ" = "file"; then
			test -x "$cmd" && warn "command '$cmd' definition file is executable"
			source "$cmd" || fail "Unexpected exit status $? while sourcing '$cmd'"
			verb "loaded command '$cmd'"
		else
			if test -n "$typ"; then
				warn "type -t '$cmd' reports '$typ'"
			else
				warn "there is nothing named '$cmd'"
				iai-help
			fi
			emsg "unknown command line '$@'"
			exit 1
		fi
	fi

	shift;
	# Quoting is neccessary, otherwise quoted args are splitted
	$cmd "$@" || exit
}

##
# BUILT-IN COMMANDS
# =================
# The commands built-in are defined as bash funcions hereafter.
# Built-in commands don't have a script file (there is no iai-command script).
# This is because they are essential, or enought simple.
##

##
# `iai help` outputs useful information about iai's command-line usage
##
iai-help () {
  iai-dependencies || exit
  info <<HELP
	##
	# Here should be some help text
	##
	> built-in commands:
	> id db dir date hora info warn fail
	TODO research functions within this file named 'iai-*'
	> available commands (\$1):
	$(tree "$(iai-path abc command)")
HELP
}

##
# `iai date` and `iai hora` standarize the date and time formats
##
iai-date () { date --rfc-3339=date || exit 1; }
iai-hora () { date --rfc-3339=seconds || exit 1; }

##
# `iai root` outputs the directory where iai resides (the "iai root").
# It's probably the most basic operation besides the "artistic" bare `iai`,
# and the `iai help` commands.
# LINK
# - http://stackoverflow.com/a/246128/1894803
# : research absolute paths to this script file and its directory
##
iai-root () {
	local SOURCE="${BASH_SOURCE[0]}" DIR=""
	while [ -h "$SOURCE" ]; do
		DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
		SOURCE="$(readlink "$SOURCE")"
		[[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
	done
	DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
	dirname $DIR
}

##
# `iai dir` is an alias for `iai root`
# TODO: `dir` is deprecated favouring `root` at it's more descriptive
##
iai-dir () {
  iai-dependencies || exit
  warn "iai-dir is deprecated, use iai-root instead"
	iai-root
}

##
# `iai-path` joins each argument to `iai-root` with slashes between.
##
iai-path () {
  printf "%s" $(iai-root)
  if test $# -gt 0; then
    # Quoting is neccessary to correctly parse arguments
    # Ex: local args=("$@"); for arg in "$@"; do echo >&2 "arg=$arg"; done
    printf "%s" "${@/#//}"
  fi
  printf "\n" # could use echo but wanted to be more explicit
}

##
# `iai-working` intentionally fails to signal a place you were working at
##
iai-working () {
  iai-dependencies || exit
	fail "You were working @ $(caller)"
}

##
# MAIN ROUTINE
# ============
PATH="$PATH:"$(iai-path abc command)""
iai "$@"
exit

##
# vim modeline
# /* vim: set filetype=sh ts=2 shiftwidth=2: */
