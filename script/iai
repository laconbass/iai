#!/bin/bash

# NOTE: `set -e` impedes try-catching commands

##
# SCRIPT DEPENDENCIES
# ===================
# - seems lighter not sourcing until something is need
# - an error may happen when the path can't be sourced 
# - should depend only on bashido?
##

iai.dependencies () {
  type -t bashido >/dev/null || { echo >&2 "FATAL: missing bashido"; exit 1; }
  source "$(bashido api)" --source-only || exit
  log.filter () {
    #return 0 # uncomment this line for max amount of verbosity
    #return 1 # uncomment this line to remove al logging
    
    test $1 != 'VV'; return; # omit verbose messages

    # log.filter receives 3 arguments:
    # $1: "lvl" (one of EE, II, VV, etc.)
    # $2: "fn" (the function where log output was requested)
    # $3: "file" (the file where the function is defined)
    # try: echo "logs $@"
    case "$1" in
      EE|WW|UX|II) return 0 ;;
      *) return 1 ;;
    esac
  }
  bashido.require "assert.common" || exit
  iai.dependencies () { true; }
  info "loaded iai dependencies"
}

##
# MAIN COMMAND
# ============
# `iai` acts as an accessor to sub-commands.
# When it's run without arguments, calls iai-artii.
##
function iai () {
  if test $# -eq 0; then iai-artii; return $?; fi

  local cmd="iai-$1"
  local typ="$(type -t "$cmd")"

  # when cmd is function, it's either builtin or an already sourced file
  # so there aren't actions needed before running the command
  if test "$typ" != "function"; then
    # when command is a file, it's assumed to be its function source file
    if test "$typ" = "file"; then
      local file="$(type -p $cmd)"
      if ! test -x "$file"
      then
        iai.dependencies || exit
        source "$file" || {
          emsg "Got exit code $? while sourcing %s" "$file"
          utip "assumed it defines a bash function because it's not executable"
          local bang="$(head -1 "$file" | grep "^#!")"
          if test -n "$bang"
          then
            case "$bang" in
              *bash*) fail "$file has a bash shebang, should be sourceable" ;;
              *node*) utip "$file has a node shebang" ;;
              *) warn "$file has an unknown shebang: %s" "$bang" ;;
            esac
            utip "try %s" "chmod +x $file && iai ${@}"
          fi
          exit 1
        }
        assert_function "$cmd" # or there is no function named $cmd at that file
        info "loaded command %s" "$cmd"
      else
        # executable files must include a shebang to be run directly
        if ! head -1 "$file" | grep -q "^#!"
        then
          iai.dependencies || exit
          emsg "unexpected start of the executable file %s" "$file"
          utip "to run this command, either:"
          utip "  1) $file should have a shebang"
          utip "     try adding a shebang to the file"
          utip "or"
          utip "  2) $file should not be executable"
          utip "     try %s" "chmod -x $file && iai ${@}"
          exit 1
        fi
      fi
    else
      iai.dependencies || exit
      if test -n "$typ"; then
        emsg "type -t '$cmd' reports '$typ'"
      else
        warn "there is nothing named %s" "$cmd"
      fi
      emsg "unknown command %s" "$1" || exit
      utip "> try %s" "iai-help"
      return 1
    fi
    type -t verb >/dev/null && verb "exec %s" "iai-${@}"
  fi

  shift;
  # Quoting is neccessary, otherwise quoted args are splitted
  $cmd "$@" # DON'T EXIT, let command decide when to exit (or return)
}

##
# BUILT-IN COMMANDS
# =================
# The commands built-in are defined as bash funcions hereafter.
# Built-in commands don't have a script file (there is no iai-command script).
# This is because they are essential, or enought simple.
##

##
# DUMB builtins: a bunch of enought simple commands
#
# - `iai-dependencies` is an utility to check if dependencies load
# - `iai-artii` randomly picks and outputs useless ascii art
# - `iai-moods` expresses a random emotion in ascii art
#   * useful to test things (either for cowboys)
##
function iai-dependencies () { iai.dependencies; }
function iai-artii () {
  local artii="$(iai-path dojo db artii)"
  cat "$(find "$artii" -type f -print0 | shuf -n 1 -z)"
}
function iai-moods () {
  local emotions="$(iai-path dojo db artii emotions)"
  case "$1" in
    "cat") cat "$emotions" ;;
    "vim") iai confirm exec "vim $emotions" ;;
    *) <"$emotions"  head -n -1 | shuf -n 1 ;;
  esac
}

##
# ESSENTIAL builtins: the real core
##

##
# `iai root` outputs the directory where iai resides (the "iai root").
# It's probably the most basic operation besides the "artistic" bare `iai`,
# and the `iai help` commands.
# LINK
# - http://stackoverflow.com/a/246128/1894803
# : research absolute paths to this script file and its directory
##
iai-root () {
  local SOURCE="${BASH_SOURCE[0]}" DIR=""
  while [ -h "$SOURCE" ]; do
    DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
  done
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  dirname $DIR
}

##
# `iai help` outputs useful information about iai's command-line usage
##
function iai-help () {
  cat <<HELP
  ===
  iai
  ===

  usage: iai [command] [command arguments ...]

  built-in commands:
  $(while read d t fn; do echo $fn; done < <(declare -F)\
       | grep "iai-"\
      | sort\
      |  while read cmd; do printf "  ${cmd##iai-}"; done
    )

  other available commands:
  $(find "$(iai-path abc command)" -type f -name "iai-*" -print0\
      | sort -z\
      | while read -d $'\0' cmd; do printf "  ${cmd##*/iai-}"; done\
    )

  other available executables:
  $(find "$(iai-path bin)" -name "iai-*" -print0\
      | sort -z\
      | while read -d $'\0' cmd; do printf "  ${cmd##*/iai-}"; done\
    )
  ---
HELP
  if { iai-repo &>/dev/null; }
  then
    iai.dependencies || exit
    if test -f README.md
    then
      utip "try '%s' for information about this directory" "iai view README.md"
    else
      warn "no README.md file was found here (%s)" "$PWD"
      utip "you should init README.md with a tree description, use '%s'"\
      "iai-tree > README.md"
    fi
  fi
}

##
# `iai-repo` researches, from $CWD upwards, the current git repository path
#
function iai-repo () {
  git rev-parse --show-toplevel 2>/dev/null || {
    iai.dependencies || exit
    emsg "Could not find git repository"
    exit 1
  }
}

##
# `iai tree` standarizes the way to display the contents of a directory
# `iai ls` standarizes the way to list the contents of a directory
# `iai pager` standarizes the way to invoke a pager
# `iai view` standarizes the way to invoke a file content viewer
##
function iai-tree () {
  tree -L 2  --dirsfirst --sort=name --noreport -C --filelimit 20 "$@"\
     | iai-pager || exit 1
}
function iai-ls () {
  ls -ohu --color=always --group-directories-first "$@"\
    | iai-pager || exit 1
}
function iai-pager () {
  # -i ignore case when searching, but respect case if term contains uppercase
  # -X (no init) do not init/reset terminal on init/exit
  # TODO option -X seems to cause conflicts with -F under certain situations
  # -F exits if text is less than one screen long
  # -R bypasses ANSI color sequences (-r bypasses all ANSI sequences)
  # -J display status column
  # -W highlight the first unread line after scrolling for more than one lines
  # -M prompt more verbosely
  # -x4 display tabs as 4-character width
  # -z-4 change default scrolling size to 4 lines fewer than current screen lines
  # -#2 set horizontal scroll (arrow left & right) to 2 spaces
  ##
  less -iXFRJWM -x4 -z-4 -#2 "$@" || exit 1
}
function iai-view () {
  local cmd="set nomodifiable" # disable insert mode
  if test $# -eq 0
  then # when reading from stdin...
    # force markdown filetype if detected filetype is 'conf'
    cmd="$cmd | if &filetype == 'conf' | set filetype=markdown | endif"
    # get rid of "E37 no write since last change" on :q
    cmd="$cmd | setlocal buftype=nofile"
  fi
  # TODO breaks with: iai view +13 /repos/iai/README.md
  vim --not-a-term -m -c "$cmd" "${@:--}"
}

##
# `iai-path` joins each argument to `iai-root` with slashes between.
# TODO: `iai path` is vage and not descriptive enought
##
function iai-path () {
  printf "%s" $(iai-root)
  if test $# -gt 0; then
    # Quoting is neccessary to correctly parse arguments
    # Ex: local args=("$@"); for arg in "$@"; do echo >&2 "arg=$arg"; done
    printf "%s" "${@/#//}"
  fi
  printf "\n" # could use echo but wanted to be more explicit
}


##
# WORKING-ON builtins: meant for use at development time
#
# `iai-working` intentionally fails to signal a place you were working at
# `iai-status` runs a command and reports its exit status
# `iai-watch` runs a command through iai-status periodically, until killed
##
function iai-working () {
  local last_code=$?
  (( last_code )) && warn "called after an exit-status %s" "$last_code"
  iai.dependencies || exit
  read line fn file <<<"$(caller 0)"
  test "$fn" = "iai" && read line fn file <<<"$(caller 1)"
  utip "You were working at function %s" $fn
  utip "to continue working on, use: %s" "vim +$line ${file}"
  exit 1
}
function iai-status () {
  "$@"; local code=$?
  printf '>> '
  ! (( $code )) && printf "OK" || printf "KO (CODE $code)"
  printf ' << '; echo "$@"
}
function iai-watch () {
  watch --beep --color --differences --interval 2 --no-title \
    iai status "$@"
}

##
# ALIASED builtins: commands being syntax sugar
##

# `iai-nbin` is syntactic sugar for `iai-path node_modules/.bin/$@`
function iai-nbin () { iai-path "node_modules/.bin" "$@"; }

# `iai wanip` and `iai lanip` are now part of iai-net toolset
function iai-wanip () { iai net wanip; }
function iai-lanip () { iai net lanip; }

##
# TRASH builtins: they are dirty, useless, or don't belong here
##

##
# `iai date` and `iai hora` standarize the date and time formats
# TODO they are actually useless
##
function iai-date () { date --rfc-3339=date || exit 1; }
function iai-time () { date --rfc-3339=seconds || exit 1; }

##
# `iai-confirm` asks for confirmation on stdin
# TODO here should be defined as an alias to 'iai ui confirm'
##
function iai-confirm () {
  iai.dependencies || exit
  read line fn file <<<"$(caller 0)"
  test "$fn" = "iai" && read line fn file <<<"$(caller 1)"

  local msg="$@"
  test -z "$msg" && warn "%s provided no confirm message" $fn
  case "$1" in
    exec) msg="execute '${@:2}'" ;;
    '') msg="confirm you want to continue" ;;
  esac

  while true
  do
    utip "%s wants to %s" $fn "$msg"
    utip "> type %s to $msg" "yes"
    utip "> type %s to see the function on the pager (line $line)" "view"
    utip "> type any other thing to cancel gracefully"
    read CONFIRM || { emsg "can't read response"; return 1; }
    case "$CONFIRM" in
      yes)
        info "action accepted"
        test "$1" == "exec" && { ${@:2}; return $?; } || return 0
        ;;
      view)
        info "viewing $file (line $line)...";
        <"$file" \
          highlight -O ansi --syntax=bash --stdout \
          | iai-pager -N4 -j$line +$line "+/$fn|iai.confirm"\
        ;;
      *) emsg "action refused ($CONFIRM)"; exit 1 ;; # TODO should return 1 instead
    esac
  done
}

##
# MAIN ROUTINE
# ============
PATH="$PATH:"$(iai-path abc command)""
PATH="$PATH:"$(iai-path bin)""
iai "$@"
exit

##
# vim modeline
# /* vim: set expandtab: */
# /* vim: set filetype=sh ts=2 shiftwidth=2: */
