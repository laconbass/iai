#!/bin/bash

# NOTE: `set -e` impedes try-catching commands

##
# SCRIPT DEPENDENCIES
# ===================
# - seems lighter not sourcing until something is need
# - an error may happen when the path can't be sourced 
# - should depend only on bashido?
##

iai.dependencies () {
	type -t bashido >/dev/null || { echo >&2 "FATAL: missing bashido"; exit 1; }
	source "$(bashido abc-call_trace)" || exit
	source "$(bashido abc-log)" || exit
	source "$(bashido assert-basic)" || exit
	log.filter () {
		return 0 # comment this line for max amount of verbosity
		return 1
		#echo "logs $@"
		test "$2" != "iai"
	}
	iai.dependencies () { true; }
  info "loaded iai dependencies"
}

##
# MAIN COMMAND
# ============
# `iai` acts as an accessor to sub-commands.
# When it's run without arguments, outputs some ascii art.
##
iai () {
  if test $# -eq 0
	then
		cat "$(iai-path dojo db artii 0110)"
    exit 0
	fi

	type -t verb >/dev/null && verb "exec %s" "iai-${@}"

	local cmd="iai-$1"
	local typ="$(type -t "$cmd")"

	if test "$typ" != "function"; then
		# when cmd is function, it's either builtin or an already sourced file
		iai.dependencies || exit
		# when command is a file, it's assumed to be its function source file
		if test "$typ" = "file"; then
			test -x "$cmd" && warn "command %s definition file is executable" $cmd
			source "$cmd" || fail "Unexpected exit code %s while sourcing %s" $? $cmd
			info "loaded command %s" "$cmd"
		else
			if test -n "$typ"; then
				emsg "type -t '$cmd' reports '$typ'"
			else
				warn "there is nothing named %s" "$cmd"
			fi
			emsg "unknown command %s" "$1"
			iai-help | utip
			exit 1
		fi
	fi

	shift;
	# Quoting is neccessary, otherwise quoted args are splitted
	$cmd "$@" || exit
}

##
# BUILT-IN COMMANDS
# =================
# The commands built-in are defined as bash funcions hereafter.
# Built-in commands don't have a script file (there is no iai-command script).
# This is because they are essential, or enought simple.
##

##
# `iai help` outputs useful information about iai's command-line usage
##

iai-help () { cat <<HELP
===
iai
===

usage: iai [command] [command arguments ...]

built-in commands:
  $(while read d t fn; do echo $fn; done < <(declare -F)\
   	| grep "iai-"\
  	| sort\
  	|	while read cmd; do printf "  ${cmd##iai-}"; done
  )

other available commands:
  $(find "$(iai-path abc command)" -type f -name "iai-*" -print0\
  	| xargs -0 basename -a\
  	| sort\
  	| while read cmd; do printf "  ${cmd##iai-}"; done
  )
HELP
}

##
# `iai date` and `iai hora` standarize the date and time formats
##
iai-date () { date --rfc-3339=date || exit 1; }
iai-hora () { date --rfc-3339=seconds || exit 1; }

##
# `iai root` outputs the directory where iai resides (the "iai root").
# It's probably the most basic operation besides the "artistic" bare `iai`,
# and the `iai help` commands.
# LINK
# - http://stackoverflow.com/a/246128/1894803
# : research absolute paths to this script file and its directory
##
iai-root () {
	local SOURCE="${BASH_SOURCE[0]}" DIR=""
	while [ -h "$SOURCE" ]; do
		DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
		SOURCE="$(readlink "$SOURCE")"
		[[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
	done
	DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
	dirname $DIR
}

##
# `iai dir` is an alias for `iai root`
# TODO: `dir` is deprecated favouring `root` at it's more descriptive
##
iai-dir () {
  iai.dependencies || exit
  warn "iai-dir is deprecated, use iai-root instead"
	iai-root
}

##
# `iai-path` joins each argument to `iai-root` with slashes between.
##
iai-path () {
  printf "%s" $(iai-root)
  if test $# -gt 0; then
    # Quoting is neccessary to correctly parse arguments
    # Ex: local args=("$@"); for arg in "$@"; do echo >&2 "arg=$arg"; done
    printf "%s" "${@/#//}"
  fi
  printf "\n" # could use echo but wanted to be more explicit
}

function iai-repo () {
	git rev-parse --show-toplevel 2>/dev/null || {
	  iai.dependencies || exit
		emsg "Could not find git repository"
		exit 1
  }
}

##
# `iai-working` intentionally fails to signal a place you were working at
##
iai-working () {
  local last_code=$?
	(( last_code )) && warn "called after an exit-status %s" "$last_code"
  iai.dependencies || exit
	read line fn file <<<"$(caller 0)"
	test "$fn" = "iai" && read line fn file <<<"$(caller 1)"
	utip "You were working at function %s" $fn
	utip "to continue working on, use: %s" "vim +$line .${file##$PWD}"
	exit 1
}

##
# MAIN ROUTINE
# ============
PATH="$PATH:"$(iai-path abc command)""
iai "$@"
exit

##
# vim modeline
# /* vim: set filetype=sh ts=2 shiftwidth=2: */
