assert_function iai || exit

iai-find () {
  [[ "$@" =~ "--help" ]] && {
    utip "here should be some help text"
    exit 0
  }
  
  local root=""
  args=()

  # -O2 enables Optimization Level 2 (see `man find`)
  # judge if supported by feature detection
  if find -O2 -false &>/dev/null
  then args+=(-O2)
  else
    warn "system's find don't support optimization level 2 (-O2)"
    warn "this behaviour is expected on busybox binarys"
  fi

  # argument parsing strategy (stage 1)
  test $# -gt 0 && warn "experimental behaviour to parse argument list"
  while test $# -gt 0; do
    case "$1" in
      # it's important to shift every arg or will loop through infinity
      '--debug') shift; debug=1; args+=(-D exec) ;;
      'in') shift; root="${1:-'missing pathspec'}"; shift ;;
      'here') shift; root="$(pwd)" ;;
      '-maxdepth') shift; opts="-maxdepth ${1:-'missin maxdepth value'}"; shift ;;
      *) break ;; # let's continue parsing after prune directives
    esac
  done

  # if no root was defined, will search within the iai root.
  if test -z "$root"; then root="$(iai-root)"; fi

  # ignore anything inside any .git directory
  args+=(-path "*/.git/*" -prune -o)
  # ignores anything inside a node_modules directory
  # , but include entities whose name matches 'iai*'
  args+=(-path "*/node_modules/*" ! -name "iai*" -prune -o)
  # third prune ignores any git repository except the root
  args+=(-exec test -e /"{}/.git" \; ! -path "$root" -prune -o)

  # argument parsing strategy (stage 2)
  while test $# -gt 0; do
    case "$1" in
      -*) args+=("$1") ;;
      *) args+=(-name "*$1*") ;;
    esac
    shift # remember to shift every arg
  done

  # if we have still arguments, something went wrong argument parsing stage 2
  test $# -gt 0 && fail "unexpected argv: %s" "$*"

  args+=(-print) # the default action is -print
  current="$(pwd)"; cd "$root" # ugly hack to remove the root path from output

  # optionally provide information about the command which will be run
  if (($debug)); then verb "find ${args[*]}"; fi

  if ! find "${args[@]}"; then
    code=$?
    emsg "find exit status was %s" "$code"
    utip "try activating %s flag for more information" "--debug"
  fi
  cd "$current" # this is need because of the ugly hack above
  return ${code:-0}
}

##
# vim modeline (see vim +'help modeline')
# /* vim: set expandtab: */
# /* vim: set filetype=sh ts=2 shiftwidth=2: */
