assert_function iai || exit

function iai-lint () {
	iai working
}

# TODO does iai-lint.project belong here?
function iai-lint.project () {
	# asserts that project at $1 complains with the iai convention
	local root="${1:?'missing the project root'}"

	# a project must be a valid directory
	assert_dir_exists "$root"
	cd "$root" || fail "could not descend into %s" "$root"

	# the convention is that each project must contain the following:
	assert_reg_exists "$root/README.md"
	assert_reg_exists "$root/package.json"
	assert_dir_exists "$root/abc"
	assert_dir_exists "$root/dojo"
	assert_dir_exists "$root/test"
  info "successfully linted %s project" "${root}"
}


function iai-lint.feature () {
	# asserts the feature whose codename is $1 complains with the iai convention
	# to rely on this function, ensure the $PWD is a valid project first
	local codename="${1:?'missing the feature codename'}"

  if test -f "abc/$codename/package.json"
	then
		info "the feature %s is a project on its own" "$codename"
		iai lint.project "$PWD/abc/$codename"
	else
		# the convention is that each feature codename must be present at:
		assert_dir_exists "$PWD/abc/$codename"
		assert_dir_exists "$PWD/test/abc/$codename"
	fi
	info "successfully linted the feature %s" "$codename"
}

function iai-lint.testbin () {
	local testbin="${1:-'missing testbin path'}"

	(assert_reg_perm_x "$testbin") || {
	  utip "the convention is that each partial must have its 'testbin'."
		utip "'testbin's are executable files, so this test fails because the file"
		utip "is either not present or not executable. You can try this solutions:"
		utip "for not present: %s" "touch $testbin"
		utip "for not executable: %s" "chmod +x $testbin"
		false
  }
	tested "$testbin is a regular file which is executable"

	## TODO this should be separate from lint.testbin
	## TODO i.e., automatically at lint.partial
	local headfile="$(iai-path dojo/db/convention/bash-head--testbin)"
	lint.head_equals "$testbin" "$headfile"
	tested "file '$testbin' head is '$headfile'"

	# generate test stats (autotest)
	local tcount=$(grep -cw "tested" "$testbin")
	local tskips=$(grep -cw "teskip" "$testbin")
	verb "found $(( $tcount + $tskips )) tests in '$testbin'"
	# generate test stats (bashido check)
	local ccount=$(grep -cw "check" "$testbin")
	verb "found $(( $ccount )) checks in '$testbin'"

	(( $tcount )) || (( $tskips )) || (( $ccount )) || {
		utip "%s was linted searching for test cases, but none was found" "$testbin"
		utip "quick'n dirty fix: %s"\
		 	"echo 'tested \"this should be tested someway though\"' >> '$testbin'"
		utip "or use %s to fix the problem by hand" "vim '$testbin'"
		false
  }
	tested "there is at least 1 test call in '$testbin'"
	(( $tskips )) && warn "$tskips skiped tests in '$testbin'"

	(( $tcount )) || (( $ccount )) || {
	  utip "$testbin only contains 'tskip' calls, so tests nothing"
		emsg "write at least one test there, cowboy fucker"
		utip "use %s now" "vim '$testbin'"
	  false
  }
	tested "something is actually tested in $testbin"
	
	local tailfile="$(iai-path dojo/db/convention/bash-tail--testbin)"
	lint.tail_equals "$testbin" "$tailfile"
	tested "file '$testbin' tail is '$tailfile'"

	info "succesfully linted %s testbin" "$testbin"
}

##
# vim modeline
# /* vim: set filetype=sh ts=2 shiftwidth=2: */
