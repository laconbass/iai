assert_function iai || exit

autotest checkup >/dev/null && source <(autotest) || exit
bashido.require "assert.lint"

# TODO remove this
source iai-lint

function iai-check () {
	# project root is researched through the builtin `iai-repo`
  local root="$(iai-repo)"
	test -n "$root" || fail "could not find project repo"

	cd "$root" || fail "could not descend into '$root'"

	case $# in
		0) iai check.project "$root" ;;
		1) iai lint.project "$root"; iai check.feature "$1" ;;
		# actually the next will fail when, plus its usability needs debate.
		#2) iai lint.feature "$1"; iai check.partial "abc/$2" ;;
		*) fail "too much arguments (%s given)" $# ;;
	esac
	iai check.done
}

function iai-check.partial () {
	# checks the partial implementation defined at $1
	# to rely on this function, ensure the $PWD is a valid feature first
	local partial="${1:?'missing partial path'}"

	(assert_reg_perm_r "$PWD/$partial") || {
	  emsg "%s is not a readable file" "$PWD/$partial"
		utip "the convention is that each file in a feature is a partial"
		utip "so partials must be readable files thought."
		false
  }
	tested "partial file actually exists"

	# research partial identifiers
	local codename="${partial%%.*}" # the relative path without file extension
	local basename="${partial##*/}" # the relative path file basename
	local prefix="${basename%%.*}" # the file codename
	local suffix="${basename#*.}" # ALL the file extensions

	# README files are skiped
	if test "$prefix" == "README"
	then
		info "partial check skiped as it's a README file"
		return 0
	fi

	# TODO maybe should return 0 and emit a warn instead
	test "${basename:0:1}" != "." || {
	  utip "partials can't be hidden files"
		false
  }
	tested "$partial, basenamed $basename, is not a hidden file"

	# TODO tests could have .bash suffix, or even .js or the like
	local testbin="$PWD/test/$codename"
	# lint the testbin (bash testbin)
	iai lint.testbin "$testbin"

	# TODO calculate progress better
	verb "run testbin %s ..." "$testbin"; SECONDS=0
	(
	  # TODO count the times that tested/teskip are called
		iai run "$testbin"
	) 1> /dev/null || {
	  utip "test exited with code %s" $?
		utip "Run %s to see details" "iai run $testbin || echo 'EXIT CODE WAS' \$?"
		false
  }
	tested "$partial testbin exits with code 0"
	verb "ran testbin in %s seconds" "$SECONDS"
  info "successfully checked %s" "$partial"
}


function iai-check.feature () {
	# checks the current iai-based feature whose codename matches exactly "$1"
	# to rely on this function, ensure the $PWD is a valid project first
	local feature="${1:?'missing feature codename'}"

	# TODO this test should rely on .git directory, not package.json
  if test -f "$PWD/abc/$feature/package.json"
	then
		# when feature is a project itself, delegate on check.project
		info "the feature %s is a project on its own" "$feature"
		local oldpwd="$PWD"
		iai check.project "$PWD/abc/$feature"
		cd "$oldpwd" # ensure we are at the project pwd to proceed
	else
		iai lint.feature "$feature"
		# feature should have tests or it's not possible to perform any check
		local count=$(find "test/abc/$feature" -type f | wc -l)
		# when no tests found, tell user where they should be
		if test "$count" -eq 0; then
			utip "Tests should be files in test/abc/$feature"
			iai ls "test/abc" | utip
			Error "no tests found for %s" "$feature"
			exit 1
		else
			verb "found $(( $count )) tests for '$feature'"
		fi
		test "$count" -gt 0
		tested "$feature has at least one testbin"

		# the convention is that each file in a feature is a partial
		# checking the feature implies checking each partial
		find "abc/$feature" -type f -print0\
			| sort -z\
			| while read -d $'\0' file; do printf '%s\0' "${file##*/$feature/}"; done\
			| while read -d $'\0' partial; do
					iai-check.partial "abc/$feature/$partial"
				done\
			;
		tested "all $feature partials"
		# there could be more test scripts than feature partials, run'em all
		autotest allin "test/abc/$feature"
		tested "all $feature test scripts"
		warn "some test scripts may have run twice"
	fi

  info "successfully checked %s" "$feature"
}

function iai-check.project () {
	# checks the current iai-based project, assumed to be at $PWD
	local root="${1:?'missing project root'}"

	iai lint.project "$root"

	# the convention is that each directory in 'abc' is a feature
	# checking the whole project implies checking each feature
	find "$root/abc" -mindepth 1 -maxdepth 1 -type d -print0\
		| sort -z\
		| while read -d $'\0' feature; do iai-check.feature ${feature##*/}; done\
		;
	tested "all ${root##*/} features"
  info "successfully checked %s project" "${root##*/}"
}

function iai-check.done () {
	info "All checks were run! good job :D"
	utip <<IMPORTANT
- Remember to commit your work if applicable
- Continue with TDD and write more test scripts.
- Don't enter cowboy coding mode please!
IMPORTANT
	verb <<TODOS
# TODO iai interactive commands (cmds that expect stdin interaction)
# TODO discovering things to be done: find files cowboy-coded
# TODO discovering things to be done: find TODO comments and display them nicely
  $(iai find | grep -i todo)
TODOS
}
##
# vim modeline
# /* vim: set filetype=sh ts=2 shiftwidth=2: */
