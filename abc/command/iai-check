#!/bin/bash

assert_function iai || exit

autotest checkup >/dev/null && source <(autotest) || exit
bashido.require "assert.lint"

function iai-check () {
	# project root is researched through the builtin `iai-repo`
  local root="$(iai-repo)"
	test -n "$root" || fail "could not find project repo"

	cd "$root" || fail "could not descend into '$root'"
	info "running for project root %s" "$root"

	case $# in
		0) iai check.project "$root" ;;
		1) iai lint.project "$root"; iai check.feature "$1" ;;
		# actually the next will fail when
		2) iai lint.feature "$1"; iai check.partial "abc/$2" ;;
		*) fail "too much arguments (%s given)" $# ;;
	esac
	iai check.done
}

function iai-check.partial () {
	# checks the partial implementation defined at $1
	# to rely on this function, ensure the $PWD is a valid feature first
	local partial="${1:?'missing partial path'}"

	info "checking the partial %s" "$PWD/$partial"

	(assert_reg_perm_r "$PWD/$partial") || {
	  emsg "%s is not a readable file" "$PWD/$partial"
		utip "the convention is that each file in a feature is a partial"
		utip "so partials must be readable files thought."
		false
  }
	tested "partial file actually exists"

	# research partial identifiers
	local codename="${partial%%.*}" # the relative path without file extension
	local basename="${partial##*/}" # the relative path file basename
	local prefix="${basename%%.*}" # the file codename
	local suffix="${basename#*.}" # ALL the file extensions

	# README files are skiped
	if test "$prefix" == "README"
	then
		info "partial check skiped as it's a README file"
		return 0
	fi

	# TODO maybe should return 0 and emit a warn instead
	test "${basename:0:1}" != "." || {
	  utip "partials can't be hidden files"
		false
  }
	tested "$partial, basenamed $basename, is not a hidden file"

	# TODO tests could have .bash suffix, or even .js or the like
	local testbin="$PWD/test/$codename"
	# lint the testbin (bash testbin)
	iai lint.testbin "$testbin"

	# TODO calculate progress better
	verb "run testbin %s ..." "$testbin"; SECONDS=0
	(
	  # TODO count the times that tested/teskip are called
		. "$testbin"
	) &> /dev/null || {
	  utip "test exited with code %s" $?
		utip "Run %s to see details" "$testbin || echo EXIT \$?"
		false
  }
	tested "$partial testbin exits with code 0"
	verb "ran testbin in %s seconds" "$SECONDS"
  info "successfully checked %s" "$partial"
}

iai-lint.testbin () {
	local testbin="${1:-'missing testbin path'}"
	info "linting the testbin %s" "$testbin"

	(assert_reg_perm_x "$testbin") || {
	  utip "the convention is that each partial must have its 'testbin'."
		utip "'testbin's are executable files, so this test fails because the file"
		utip "is either not present or not executable. You can try this solutions:"
		utip "for not present: %s" "touch $testbin"
		utip "for not executable: %s" "chmod +x $testbin"
		false
  }
	tested "$testbin is a regular file which is executable"

	## TODO this should be separate from lint.testbin
	## TODO i.e., automatically at lint.partial
	local headfile="$(iai-path dojo/db/convention/bash-head--testbin)"
	lint.head_equals "$testbin" "$headfile"
	tested "file '$testbin' head is '$headfile'"

	# generate test stats (autotest)
	local tcount=$(grep -cw "tested" "$testbin")
	local tskips=$(grep -cw "teskip" "$testbin")
	verb "found $(( $tcount + $tskips )) tests in '$testbin'"
	# generate test stats (bashido check)
	local ccount=$(grep -cw "check" "$testbin")
	verb "found $(( $ccount )) checks in '$testbin'"

	(( $tcount )) || (( $tskips )) || (( $ccount )) || {
		utip "%s was linted searching for test cases, but none was found" "$testbin"
		utip "quick'n dirty fix: %s"\
		 	"echo 'tested \"this should be tested someway though\"' >> '$testbin'"
		utip "or use %s to fix the problem by hand" "vim '$testbin'"
		false
  }
	tested "there is at least 1 test call in '$testbin'"
	(( $tskips )) && warn "$tskips skiped tests in '$testbin'"

	(( $tcount )) || (( $ccount )) || {
	  utip "$testbin only contains 'tskip' calls, so tests nothing"
		emsg "write at least one test there, cowboy fucker"
		utip "use %s now" "vim '$testbin'"
	  false
  }
	tested "something is actually tested in $testbin"
	
	local tailfile="$(iai-path dojo/db/convention/bash-tail--testbin)"
	lint.tail_equals "$testbin" "$tailfile"
	tested "file '$testbin' tail is '$tailfile'"

	info "succesfully linted %s testbin" "$testbin"
}

function iai-check.feature () {
	# checks the current iai-based feature whose codename matches exactly "$1"
	# to rely on this function, ensure the $PWD is a valid project first
	local feature="${1:?'missing feature codename'}"

	info "checking the feature %s" "$feature"

  if test -f "$PWD/abc/$feature/package.json"
	then
		# when feature is a project itself, delegate on check.project
		info "the feature %s is a project on its own" "$feature"
		iai check.project "$PWD/abc/$feature"
	else
		iai lint.feature "$feature"
		# feature should have tests or it's not possible to perform any check
		local count=$(find "test/abc/$feature" -type f | wc -l)
		# when no tests found, tell user where they should be
		if test "$count" -eq 0; then
			utip "Tests should be files in test/abc/$feature"
			iai ls "test/abc" | utip
			Error "no tests found for %s" "$feature"
			exit 1
		else
			verb "found $(( $count )) tests for '$feature'"
		fi
		test "$count" -gt 0
		tested "$feature has at least one testbin"

		# the convention is that each file in a feature is a partial
		# checking the feature implies checking each partial
		find "abc/$feature" -type f -print0\
			| sort -z\
			| while read -d $'\0' file; do printf '%s\0' "${file##*/$feature/}"; done\
			| while read -d $'\0' partial; do
					iai-check.partial "abc/$feature/$partial"
				done\
			;
		tested "all $feature partials"
		# there could be more test scripts than feature partials, run'em all
		autotest allin "test/abc/$feature"
		tested "all $feature test scripts"
		warn "some test scripts may have run twice"
	fi

  info "successfully checked %s" "$feature"
}

# TODO does iai-assert.feature belong here?
function iai-lint.feature () {
	# asserts the feature whose codename is $1 complains with the iai convention
	# to rely on this function, ensure the $PWD is a valid project first
	local codename="${1:?'missing the feature codename'}"
	info "linting the feature %s" "$codename"

  if test -f "abc/$codename/package.json"
	then
		info "the feature %s is a project on its own" "$codename"
		iai lint.project "$PWD/abc/$codename"
	else
		# the convention is that each feature codename must be present at:
		assert_dir_exists "$PWD/abc/$codename"
		assert_dir_exists "$PWD/test/abc/$codename"
	fi
	info "successfully linted the feature %s" "$codename"
}

function iai-check.project () {
	# checks the current iai-based project, assumed to be at $PWD
	local root="${1:?'missing project root'}"
	info "checking the project %s" "${root##*/}"

	iai lint.project "$root"

	# the convention is that each directory in 'abc' is a feature
	# checking the whole project implies checking each feature
	find "$root/abc" -mindepth 1 -maxdepth 1 -type d -print0\
		| sort -z\
		| while read -d $'\0' feature; do iai-check.feature ${feature##*/}; done\
		;
	tested "all ${root##*/} features"
  info "successfully checked %s project" "${root##*/}"
}

# TODO does iai-lint.project belong here?
function iai-lint.project () {
	# asserts that project at $1 complains with the iai convention
	local root="${1:?'missing the project root'}"
	info "linting the project %s" "$root"

	# a project must be a valid directory
	assert_dir_exists "$root"
	cd "$root" || fail "could not descend into %s" "$root"

	# the convention is that each project must contain the following:
	assert_reg_exists "$root/README.md"
	assert_reg_exists "$root/package.json"
	assert_dir_exists "$root/abc"
	assert_dir_exists "$root/dojo"
	assert_dir_exists "$root/test"
  info "successfully linted %s project" "${root}"
}

function iai-check.done () {
	info "All tests were run! good job :D"
	utip <<IMPORTANT
- Remember to commit your work if applicable
- Continue with TDD and write more test scripts.
- Don't enter cowboy coding mode please!
IMPORTANT
	verb <<TODOS
# TODO iai interactive commands (cmds that expect stdin interaction)
# TODO discovering things to be done: find files cowboy-coded
# TODO discovering things to be done: find TODO comments and display them nicely
  $(iai find | grep -i todo)
TODOS
}
##
# vim modeline
# /* vim: set filetype=sh ts=2 shiftwidth=2: */
