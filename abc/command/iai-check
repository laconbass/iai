#!/bin/bash

assert_function iai || exit
autotest checkup >/dev/null && source <(autotest) || exit
source "$(bashido assert-lint)"

function iai-check () {
	# project root is researched through the builtin `iai-repo`
  local root="$(iai-repo)"
	test -n "$root"\
	  && cd "$root"\
		|| fail "current working directory is not a project (neither its parents)"\
		;
	case $# in
		0) iai-check.project "$root" ;;
		1) iai-assert.project "$root"; iai-check.feature "$1" ;;
		2) iai-assert.feature "$1"; iai-check.partial "$1" "$2" ;;
		*) fail "too much arguments (%s given)" $# ;;
	esac
	iai-check.done
}

function iai-check.partial () {
	# checks the partial implementation of feature "$1" which is defined at $2
	local feature="${1:?'missing feature codename'}"
	local partial="${2:?'missing partial relative path'}"

	# research partial identifiers
	local codename="${partial%%.*}" # the relative path without file extension
	local basename="${partial##*/}" # the relative path file basename
	local prefix="${basename%%.*}" # the file codename
	local suffix="${basename#*.}" # ALL the file extensions

	# README files are skiped
	test "$prefix" == "README" && return 0

	info "checking the partial %s" "$feature/$partial"

	# TODO maybe should return 0 and emit a warn instead
	test "${basename:0:1}" != "." || {
	  utip "partials can't be hidden files"
		false
  }
	tested "$feature/$partial, basenamed $basename, is not a hidden file"

	# TODO tests could have .bash suffix, or even .js or the like
	local testbin="test/abc/$feature/${partial%%.*}"
	(assert_reg_perm_x "$testbin") || {
	  utip "the convention is that each partial must have its 'testbin'."
		utip "'testbin's are executable files, so this test fails because the file"
		utip "is either not present or not executable. You can try this solutions:"
		utip "for not present: %s" "touch $testbin"
		utip "for not executable: %s" "chmod +x $testbin"
		false
  }
	tested "$feature/$partial has a test file which is executable"

	# generate test stats (autotest)
	local tcount=$(grep -cw "tested" "$testbin")
	local tskips=$(grep -cw "teskip" "$testbin")
	verb "found $(( $tcount + $tskips )) tests in '$testbin'"
	# generate test stats (bashido check)
	local ccount=$(grep -cw "check" "$testbin")
	verb "found $(( $ccount )) checks in '$testbin'"

	# lint the testbin
	(( $tcount )) || (( $tskips )) || (( $ccount )) || {
		utip "$testbin was linted searching for test cases, but none was found"
		false
  }
	tested "there is at least 1 test call in '$testbin'"
	(( $tskips )) && warn "$tskips skiped tests in '$testbin'"

	local headfile="$(iai-path dojo/db/convention/bash-head--testbin)"
	local tailfile="$(iai-path dojo/db/convention/bash-tail--testbin)"
	assert_head_equal "$testbin" "$headfile"
	tested "file '$testbin' head is '$headfile'"
	assert_tail_equal "$testbin" "$tailfile"
	tested "file '$testbin' tail is '$tailfile'"

	# TODO calculate progress better
	verb "run testbin %s ..." "$testbin"; SECONDS=0
	(
	  # TODO count the times that tested/teskip are called
		./"$testbin"
	) &> /dev/null || {
	  utip "test exited with code %s" $?
		utip "Run %s to see details" "./$testbin || echo EXIT \$?"
		false
  }
	tested "$partial implementation for $feature"
	verb "ran testbin in %s seconds" "$SECONDS"
  info "successfully checked %s" "$feature/$partial"
}

function iai-check.feature () {
	# checks the current iai-based feature whose codename matches exactly "$1"
	local feature="${1:?'missing feature codename'}"

  if test -f "abc/$feature/package.json"
	then
		info "the feature %s is a project on its own" "$feature"
		local oldpwd="$PWD" newpwd="$PWD/abc/$feature"
		cd "$newpwd" || exit
		iai-check.project "$newpwd"
		cd "$oldpwd"
		return
	fi

	info "checking the feature %s" "$feature"
	iai-assert.feature "$feature"

	# feature should have tests or it's not possible to perform any check
	local count=$(find "test/abc/$feature" -type f | wc -l)
	echo "test count is $count"
	# when no tests found, tell user where they should be
	if test "$count" -eq 0; then
		emsg "no tests found for %s" "$feature"
	  utip "Tests should be files in test/abc/$feature"
	  iai tree test/abc/$feature | utip
		exit 1
	else
	  verb "found $(( $count )) tests for '$feature'"
	fi
	test "$count" -gt 0
	tested "$feature has at least one testbin"

	# the convention is that each file in a feature is a partial
	# checking the feature implies checking each partial
	find "abc/$feature" -type f -print0\
		| sort -z\
		| while read -d $'\0' file; do printf '%s\0' "${file##*/$feature/}"; done\
		| while read -d $'\0' partial; do
				iai-check.partial "$feature" "$partial"
			done\
		;
	tested "all $feature partials"
	# there could be more test scripts than feature partials, run'em all
	autotest allin "test/abc/$feature"
	tested "all $feature test scripts"
	warn "some test scripts may have run twice"
  info "successfully checked %s" "$feature"
}

# TODO does iai-assert.feature belong here?
function iai-assert.feature () {
	# asserts the feature whose codename is $1 complains with the iai convention
	# to rely on this function, ensure the $PWD is a valid project first
	local codename="${1:?'missing the feature codename'}"
	# the convention is that each feature codename must be present at:
	assert_dir_exists "$PWD/abc/$codename"
	assert_dir_exists "$PWD/test/abc/$codename"
}

function iai-check.project () {
	# checks the current iai-based project, assumed to be at $PWD
	local root="${1:?'missing project root'}"
	info "checking the project %s" "${root##*/}"
	iai-assert.project "$root"
	# the convention is that each directory in 'abc' is a feature
	# checking the whole project implies checking each feature
	find "$root/abc" -mindepth 1 -maxdepth 1 -type d -print0\
		| sort -z\
		| xargs -0 basename -az\
		| while read -d $'\0' feature; do iai-check.feature $feature; done\
		;
	tested "all ${root##*/} features"
  info "successfully checked %s project" "${root##*/}"
}

# TODO does iai-assert.project belong here?
function iai-assert.project () {
	# asserts that project at $1 complains with the iai convention
	local root="${1:?'missing the project root'}"
	# the convention is that each project must contain the following:
	assert_reg_exists "$root/README.md"
	assert_reg_exists "$root/package.json"
	assert_dir_exists "$root/abc"
	assert_dir_exists "$root/dojo"
	assert_dir_exists "$root/test"
}

function iai-check.done () {
	info "All tests were run! good job :D"
	warn <<IMPORTANT
- Remember to commit your work if applicable
- Continue with TDD and write more test scripts.
- Don't enter cowboy coding mode please!
IMPORTANT
	utip <<TODOS
# TODO iai interactive commands (cmds that expect stdin interaction)
# TODO discovering things to be done: find files cowboy-coded
# TODO discovering things to be done: find TODO comments and display them nicely
  $(iai find | grep -i todo)
TODOS
}
##
# vim modeline
# /* vim: set filetype=sh ts=2 shiftwidth=2: */
