#!/bin/bash

assert_function iai || exit

function iai-check () {
	autotest checkup >/dev/null && source <(autotest) || exit
	case $# in
		0) iai-check.project ;;
		1) iai-check.feature "$1" ;;
		2) iai-check.partial "$1" "$2" ;;
	esac
}

function iai-check.partial () {
	# checks the partial implementation of feature "$1" which is defined at $2
	local feature="${1:?'missing partial relative path'}"
	local partial="${2:?'missing partial relative path'}"
	# cd to the current iai project, so iai-assert.partial is authoritative
	cd "$(iai-repo)"\
		&& info "checking the partial %s" "$feature/$partial"\
		|| fail "current working directory is not a project (neither its parents)"\
		;
	# ensure the feature complains the filesystem structure convention
	iai-assert.partial "$feature/${partial%%.*}"
	# TODO research the partial testbin
	# TODO run the partial testbin
	emsg "i should run $feature/$partial testbin"
	tested "$partial implementation for $feature"
  info "successfully checked %s" "$feature/$partial"
}

function iai-check.feature () {
	# checks the current iai-based feature whose codename matches exactly "$1"
	local feature="${1:?'missing feature codename'}"
	# cd to the current iai project, so iai-assert.feature is authoritative
	cd "$(iai-repo)"\
		&& info "checking the feature %s" "$feature"\
		|| fail "current working directory is not a project (neither its parents)"\
		;
	# ensure the feature complains the filesystem structure convention
	iai-assert.feature "$feature"
	# there could be more test scripts than feature partials, run'em all
	autotest allin "test/abc/$feature"
	find "abc/$feature" -type f -print0\
		| sort -z\
		| while read -d $'\0' file; do printf '%s\0' "${file##*/$feature/}"; done\
		| while read -d $'\0' partial; do iai-check "$feature" "$partial"; done\
		;
	tested "all $feature partials"
  info "successfully checked %s" "$feature"
}

function iai-check.project () {
	# checks the current iai-based project
	# project root is researched through the builtin `iai-repo`
  local root="$(iai-repo)"
	test -n "$root"\
		&& info "checking the project %s" "${root##*/}"\
		|| fail "current working directory is not a project (neither its parents)"\
		;
	# ensure the project complains the filesystem structure convention
	iai-assert.project "$root"
	# the convention is that each directory in 'abc' is a feature
	# checking the whole project implies checking each feature
	find "$root/abc" -mindepth 1 -maxdepth 1 -type d -print0\
		| sort -z\
		| xargs -0 basename -az\
		| while read -d $'\0' feature; do iai-check $feature; done\
		;
	tested "all ${root##*/} features"
  info "successfully checked %s project" "${root##*/}"

	info "All tests were run! good job :D"
	warn <<IMPORTANT
- Remember to commit your work if applicable
- Continue with TDD and write more test scripts.
- Don't enter cowboy coding mode please!
IMPORTANT
	utip <<TODOS
# TODO iai interactive commands (cmds that expect stdin interaction)
# TODO discovering things to be done: find files cowboy-coded
# TODO discovering things to be done: find TODO comments and display them nicely
  $(iai find | grep -i todo)
TODOS
}

# TODO iai-assert.project does not belong here
function iai-assert.project () {
	# asserts that project at $1 complains with the iai convention
	local root="${1:?'missing the project root'}"
	# the convention is that each project must contain the following:
	assert_dir_exists "$root/abc"
	assert_dir_exists "$root/dojo"
	assert_dir_exists "$root/test"
	assert_reg_exists "$root/README.md"
}

function iai-assert.feature () {
	# asserts the feature whose codename is $1 complains with the iai convention
	# to rely on this function, ensure the $PWD is a valid project first
	local codename="${1:?'missing the feature codename'}"
	# the convention is that each feature codename must be present at:
	assert_dir_exists "$PWD/abc/$codename"
	assert_dir_exists "$PWD/test/abc/$codename"
}

function iai-assert.partial () {
	# asserts the partial codenamed $1 complains with the iai convention
	# to rely on this function, ensure the $PWD is a valid project first
	local codename="${1:?'missing the partial codename'}"
	# the convention is that each partial codename must be present at:
	warn "partial %s convention not implemented" "$codename"
}

##
# vim modeline
# /* vim: set filetype=sh ts=2 shiftwidth=2: */
