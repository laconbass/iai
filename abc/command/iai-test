assert_function iai || exit

function iai-test () {
  local reporter="iai-test.report" report="dot-code"
  local fullpath="$(iai path test/abc)" action="allin"

  while test $# -gt 0
  do
    if is_function "$reporter-$1"; then report=$1
    elif test "$1" == "bail"; then report="fails"; action="bail"
    elif test -d "$1"; then fullpath="$(realpath $1)"
    elif test -f "$1"; then fullpath="$(realpath $1)"; action="alone"
    else fail "unexpected argument (%s)" "$1"; fi
    shift # remove the parsed argument
  done
  assert_function "iai-test.$action"; assert_function "$reporter-$report"
  "iai-test.$action" "$fullpath" | "$reporter-$report"
}

function iai-test.allin () {
  test $# -eq 1 || fail "expecting one argument"
  test -d "$1" || fail "'$1' is not a directory"
  find "$1" -type f -executable -exec autotest report '{}' \;
}

# TODO DRY please
function iai-test.bail () {
  test $# -eq 1 || fail "expecting one argument"
  test -d "$1" || fail "'$1' is not a directory"
  find "$1" -type f -executable \( -exec autotest report '{}' \; -o -quit \)
}

function iai-test.alone () {
  test $# -eq 1 || fail "expecting one argument"
  test -f "$1" || fail "%s is not a file" "$1"
  autotest report "$1"
}

function iai-test.report-dots () {
  while read keyword value; do
    case $keyword in
      TEST) printf "[" ;;
      PASS) printf "·" ;;
      FAIL) printf "X" ;;
      SKIP) printf "-" ;;
      CODE) printf "]%s" "$value";;
    esac
  done; printf '\n'
}

function iai-test.report-dot-code () {
  while read keyword value; do
    case $keyword in
      TEST) printf "%s\t[" "${value#$PWD/}" ;;
      PASS) printf "·" ;;
      FAIL) printf "X" ;;
      SKIP) printf "-" ;;
      CODE) printf "]\t"; (( $value )) && echo "CODE $value" || echo "OK" ;;
    esac
  done
}

# TODO this is so ugly on screen
function iai-test.report-fails () {
  local fails=0
  while read keyword value; do
    case $keyword in
      TEST) printf "> %s ...\n" "${value#$PWD/}" ;;
      PASS|SKIP) : ;;
      FAIL) printf "|> %s\n" "$value"; let fails++ ;;
      CODE)
        if (($value)) || (($fails)); then
          local expected="0"
          (($fails)) && expected="not 0"
          printf "|> status code was %s while expecting %s\n" $value "$expected"
          printf "|> CODE $value (%s fails)\n" "$fails"
          break # bail on first test that fails
        else
          echo "OK"
        fi
    esac
  done
}

##
# vim modeline
# /* vim: set expandtab: */
# /* vim: set filetype=sh ts=2 shiftwidth=2: */
