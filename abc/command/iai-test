assert_function iai || exit

function iai-test () {
  local reporter="iai-test.report" report="dot-code"
  local fullpath="$(iai path test)" action="allin" runner="every"

  while test $# -gt 0
  do
    if is_function "$reporter-$1"; then report=$1
    elif test "$1" == "bail"; then report="fails"; runner="code0"
    elif test "$1" == "list"; then report="as-is"; runner="list"
    elif test -d "$1"; then fullpath="$(realpath $1)"
    elif test -f "$1"; then fullpath="$(realpath $1)"; action="alone"
    else fail "unexpected argument (%s)" "$1"; fi
    shift # remove the parsed argument
  done

  # don't trust the argument parsing strategy above
  assert_function "iai-test.$action"
  assert_function "iai-test.run-$runner"
  assert_function "$reporter-$report"

  # now it's guaranteed all commands are functions
  "iai-test.$action" "$fullpath" \
    | "iai-test.run-$runner" \
    | "$reporter-$report"
  info "test completed, ${PIPESTATUS[0]} ${PIPESTATUS[1]} ${PIPESTATUS[2]}"
}

function iai-test.allin () {
  test $# -eq 1 || fail "expecting one argument"
  test -d "$1" || fail "'$1' is not a directory"
  verb "searching all test executables in %s" "$(realpath $1)"
  find "$1" -type f -executable -print0 | sort -z
}

function iai-test.alone () {
  test $# -eq 1 || fail "expecting one argument"
  test -f "$1" || fail "%s is not a file" "$1"
  printf "%s%b" "$1" '\0'
}

# TEST RUNNERS: generate a report for each file in zero-terminated list (stdin)
# NOTE: ensure the test execution does not read our pipe redirecting /dev/null into
# NOTE: if it reads, the zero-terminated file list we are reading will loss data

function iai-test.run-every () {
  while IFS= read -d '' file; do
    verb "generating report for %s" "$file"
    autotest report "$file" </dev/null
  done
}

function iai-test.run-code0 () {
  while IFS= read -d '' file; do
    verb "generating report for %s" "$file"
    autotest report "$file" </dev/null || {
      local code=$?; emsg "bail on code $code"; return $code;
    }
  done
}

function iai-test.run-list () {
  while IFS= read -d '' file; do printf '%s\n' "${file#$PWD/}"; done
}

# REPORT FORMATTING

function iai-test.report-as-is () { cat; }

function iai-test.report-dots () {
  while read keyword value; do
    case $keyword in
      TEST) printf "[" ;;
      PASS) printf "·" ;;
      FAIL) printf "X" ;;
      SKIP) printf "-" ;;
      CODE) printf "]%s" "$value";;
    esac
  done; printf '\n'
}

function iai-test.report-dot-code () {
  while read keyword value; do
    while read -d ':' DIR; do value="${value//$DIR\//}"; done <<<"$PATH"
    case $keyword in
      TEST) printf "%s [" "${value#$PWD/}" ;;
      PASS) printf "·" ;;
      FAIL) printf "X" ;;
      SKIP) printf "-" ;;
      CODE) printf "] "
        read -d ' ' code <<<"$value"
        echo "$(autotest code "$code" 2>/dev/null)"
        ;;
      *) fail "Unexpected %s" "$keyword $value" ;;
    esac
  done
}

function iai-test.report-fails () {
  local fails=0
  while read keyword value; do
    while read -d ':' DIR; do value="${value//$DIR\//}"; done <<<"$PATH"
    case $keyword in
      TEST) printf "↓ %s ..." "${value//$PWD\//}"; fails=0; SECONDS=0 ;;
      PASS|SKIP) : ;;
      FAIL) printf "\n → %s" "${value//$PWD\//}"; let fails++ ;;
      CODE)
        read -d ' ' code <<<"$value"
        if (($fails)); then
          printf "\n↑ CODE $value (%s fails) in ${SECONDS}s\n" "$fails"
        else
          printf " ← OK in ${SECONDS}s\n"
        fi
        ;;
      *) fail "Unexpected %s" "$keyword $value" ;;
    esac
  done
}

##
# vim modeline
# /* vim: set expandtab: */
# /* vim: set filetype=sh ts=2 shiftwidth=2: */
