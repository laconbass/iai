assert_function iai || exit

function iai-test () {
  local reporter="iai-test.report" report="dot-code"
  local fullpath="$(iai path test)" action="allin" runner="every"

  while test $# -gt 0
  do
    if is_function "$reporter-$1"; then report=$1
    elif test "$1" == "bail"; then report="fails"; runner="code0"
    elif test "$1" == "list"; then report="as-is"; runner="list"
    elif test -d "$1"; then fullpath="$(realpath $1)"
    elif test -f "$1"; then fullpath="$(realpath $1)"; action="alone"
    else fail "unexpected argument (%s)" "$1"; fi
    shift # remove the parsed argument
  done

  # don't trust the argument parsing strategy above
  assert_function "iai-test.$action"
  assert_function "iai-test.run-$runner"
  assert_function "$reporter-$report"

  # now it's guaranteed all commands are functions
  "iai-test.$action" "$fullpath" \
    | "iai-test.run-$runner" \
    | "$reporter-$report"
}

function iai-test.allin () {
  test $# -eq 1 || fail "expecting one argument"
  test -d "$1" || fail "'$1' is not a directory"
  verb "searching all test executables in %s" "$(realpath $1)"
  find "$1" -type f -executable -print0 | sort -z
}

function iai-test.alone () {
  test $# -eq 1 || fail "expecting one argument"
  test -f "$1" || fail "%s is not a file" "$1"
  printf "%s%b" "$1" '\0'
}

# TEST RUNNERS: generate a report for each file in zero-terminated list (stdin)

function iai-test.run-every () {
  # ensure the test execution does not read our pipe redirecting /dev/null into
  # if it reads, the zero-terminated file list we are reading will loss data
  while IFS= read -d '' file; do autotest report "$file" </dev/null; done
}

function iai-test.run-code0 () {
  while IFS= read -d '' file; do
    autotest report "$file" || { info "bail on code $?"; break; }
  done
}

function iai-test.run-list () {
  while IFS= read -d '' file; do printf '%s\n' "${file#$PWD/}"; done
}

# REPORT FORMATTING

function iai-test.report-as-is () { cat; }

function iai-test.report-dots () {
  while read keyword value; do
    case $keyword in
      TEST) printf "[" ;;
      PASS) printf "·" ;;
      FAIL) printf "X" ;;
      SKIP) printf "-" ;;
      CODE) printf "]%s" "$value";;
    esac
  done; printf '\n'
}

function iai-test.report-dot-code () {
  while read keyword value; do
    case $keyword in
      TEST) printf "%s\t[" "${value#$PWD/}" ;;
      PASS) printf "·" ;;
      FAIL) printf "X" ;;
      SKIP) printf "-" ;;
      CODE) printf "]\t"; (( $value )) && echo "CODE $value" || echo "OK" ;;
    esac
  done
}

# TODO this is so ugly on screen
function iai-test.report-fails () {
  local fails=0
  while read keyword value; do
    case $keyword in
      TEST) printf "> %s ...\n" "${value#$PWD/}" ;;
      PASS|SKIP) : ;;
      FAIL) printf "|> %s\n" "$value"; let fails++ ;;
      CODE)
        if (($value)) || (($fails)); then
          local expected="0"
          (($fails)) && expected="not 0"
          printf "|> status code was %s while expecting %s\n" $value "$expected"
          printf "|> CODE $value (%s fails)\n" "$fails"
          break # bail on first test that fails
        else
          echo "OK"
        fi
    esac
  done
}

##
# vim modeline
# /* vim: set expandtab: */
# /* vim: set filetype=sh ts=2 shiftwidth=2: */
