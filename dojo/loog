#!/bin/bash
##

# Emulate a command which outputs to stdout and stderr, and exits with a custom code
emulate_cmd () {
	echo "write-this-to-stdout"
	echo "write-this-to-stderr" >&2
	exit 35 # exit code should be "recoverable" too
}

##
# utility to capture command's output from previous work at "gizmotractor" script
# - usage: `myprocess > >(loog fancyname warn)` or `myprocess > >(loog othername info)`
# TODO exit (fail) when on warn mode and line matches some predefined expresssions
loog () {
	local prefix="$1" mode="${2:-info}";
	verb "$FUNCNAME prefix=$prefix mode=$mode created at level $BASH_SUBSHELL"
	while read -r line; do $mode "$prefix: $line"; done;
}
# emulated log levels for use with loog
verb () { echo >&2 "VERB: $@"; }
info () { echo >&2 "INFO: $@"; }
warn () { echo >&2 "WARN: $@"; }

##
# With the aproach below, stdout capture happens at current scope
# This should be used at gizmotractor to properly update session state
loog "stdoutbuff" < <( emulate_cmd 2> >(loog "stderrbuff" warn) )
# Could not find a way to recover exit status
echo "\$?=$? PIPESTATUS=${PIPESTATUS[@]}"


{ # stdout of this group is sent to /dev/null
cat <<NOTES
## REMEMBER TO CHECK-OUT
> help declare
> cat dojo/gizmotractor
NOTES
echo
echo "## Another aproach could be using extra file pointers"
echo "   (from http://unix.stackexchange.com/a/28761/49721)"
cat <<'APROACH3'
	#!/bin/bash

	verbose=0

	exec 3>&1
	exec 4>&2

	if ((verbose)); then
		echo "verbose=1"
	else
		echo "verbose=0"
		exec 1>/dev/null
		exec 2>/dev/null
	fi

	echo "this should be seen if verbose"
	#Then add 1>&3 2>&4 only to commands of which you want to see the output
	echo "this should always be seen" 1>&3 2>&4
APROACH3
echo
cat <<'APROACH32'
# It's also possible to setup and release file descriptors as below
exec 3>&1 4>&2 # set up extra file descriptors
exec 3>&- 4>&- # release the extra file descriptors
APROACH32
} >/dev/null
# vim modeline
# /* vim: set filetype=sh ts=2 shiftwidth=2: */
