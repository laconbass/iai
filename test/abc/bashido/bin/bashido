#!/bin/bash

##
# waits $1 seconds until process $pid finishes. If timeout is reached,
# returns status 1 and kills the process. Returns 0 if process exits before
# timeout is reached.
# TODO should return process exit status when process exited before timeout
##
wait_timeout () {
	local out=${1:?provide a number of seconds}
	local pid=${2:?provide a process id}
	SECONDS=0
	while ps | grep $pid > /dev/null
	do
		if test $SECONDS -lt $out
		then
			echo "pid $$ waiting ($out secs) for process $pid"
			sleep 1
		else
			echo "pid $$ timeout ($out secs) for process $pid"
			kill $pid &>/dev/null
			return 1
		fi
	done
	return 0
}

will () {
	echo "will ${1:?provide an informational message}"
}

check_sources_in () {
	local dir="${1:?provide a directory}"
	local timeout=${2:-2}
	echo "checking each *.bash file in $dir is sourced at most in ${timeout}s"
	while read file; do
		printf '%s' 'Â·'
		( source "$file" ) &>/dev/null &
		wait_timeout $timeout $! >/dev/null || {
			echo "cant source '$file' in 2 seconds"
			return 1
		}
	done < <(find "$dir" -type f -name "*.bash")
	printf ' %s\n' 'OK'
}

IAI_ROOT="$(iai root)"

while !	check_sources_in "$IAI_ROOT/abc/bashido/lib"
do
	# TODO this is how to determine if stdin is a tty (interactive mode)
	test -t 0 || exit 1
	echo "will open '$file' with vim"
	echo "press any key to continue (^C to exit)"
	read -n 1
	vim "$file"
	continue
done

# TODO test the bashido bin

##
# vim modeline
# /* vim: set filetype=sh ts=2 shiftwidth=2: */
