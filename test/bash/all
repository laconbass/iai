#!/bin/bash

# Can't use `-e`, or it's not possible to "catch" errors after they fire up
set +e

##
# testing toolset is the first thing to check for
# TODO testodo <<<"tool to report tests pending to write"
testools=(tested teskip)

for tool in ${testools[@]}; do source "$(bashido autotest-$tool)"; done

report="$( for tool in ${testools[@]}; do ${tool}--test "$tool" || exit; done )" || {
  echo "###################################"
  echo "- - - check bash errors above - - -"
  echo "             = = = = =             "
  echo "     TEST TOOLS CHECKUP FAILED     "
  echo "             = = = = =             "
	echo "- - - check test report below - - -"
  echo "###################################"
	echo "$report"
  echo "###################################"
  echo "Sorry, can't run test suite because 'testools' checkup failed"
	exit 1
}

####
# Capturing any command's stderr and stdout separately
# TODO should this be at autotest-testrun.bash ?
#
## Reference
# Basis found at http://stackoverflow.com/q/11027679/1894803
# the working (and ugly) aproach is using `eval` and `typeset -p` (`declare`)
# it's well explained at http://stackoverflow.com/a/26827443/1894803
# but as seen at http://stackoverflow.com/a/28796214/1894803
# it can be refactored ussing a helper function and `printf -v`
#
## Example
# eval "$(declare_results 'commandline with argument list')"
# echo "stdout is: |$stdout| stderr is: |$stderr| return code is: |$exited|"
declare_stdin_as () { printf -v "$1" "%s" "$(cat)"; typeset -p "$1"; }
declare_results () {
	local cmd="$@"
	("$cmd") 2> >(declare_stdin_as stderr) 1> >(declare_stdin_as stdout)
	declare_stdin_as exited <<<"$?"
}

# TODO Could be better checking for test filenames based on code filenames?
# TODO for example, list bash/*.bash and check every lib file has tests
# TODO it would ease pending test identify
#test $(find test/bash -name "bashlib-*" | wc -l) -gt 0
#tested "there are at least 1 bash test"
#find test/bash -name "bashlib-*" -exec './{}' \;
run_tests_for () {
	local prefix="${1:?"$FUNCNAME: argument must be specified (prefix)"}"

	# TODO iterating over an array of filenames is a "bash-bad-practice"
	# TODO i should use `find` with `-exec` action instead
  testfiles=("$(ls test/bash/${prefix}-*)")

	test "${#testfiles[@]}" -gt "0" ;tested "'$prefix' has at least 1 test file"

	for file in ${testfiles[@]}; do
		# TODO content convention tests
		# ex: `grep "[ ;]tested[ ]" test/bash/bashlib-assert-code`
		#   to seek tested calls and check the code style for them
		# TODO generate stats to calculate progress Â¿or even introspection?
		# ex: `grep -c "[ ;]tested[ ]" test/bash/bashlib-assert-code`
		#   to count the minimum expected times that `tested` should be called

		local basename="$(basename "$file")"
		echo "> Running test file '$file'..." # pad reports
		SECONDS=0 # Crude time calc from http://stackoverflow.com/a/8903280/1894803
		eval "$(declare_results "./$file")"
		(( exited )) && {
		  echo "  ./$file exited with code $exited"
			if test -n "$stdout"; then
				echo "  - - stdout - -"; echo "$stdout"; echo "  - - * ** * - -"
			fi
			if test -n "$stderr"; then
				echo "  - - stderr - -"; echo "$stderr"; echo "  - - * ** * - -"
			fi
	  }
		test $exited -eq 0
		tested "running $basename in a subshell returns 0 (${SECONDS}s)"
		# exec file in a subshell avoids env pollution and unexpected exits
		# declare_results actually execs command line within a subshell

		# TODO measure the time spent by each test better, consider `time`
		# TODO dot animation while running?
		# TODO progress could be `echo .` for each tested call?
		# TODO both outs were hidden because working with a test fail implies isolating
		# TODO interactively allow developer at this tty (if it's a tty) to do so?
		# TODO maybe save report=$(./$file) and print it if failed?
	done
	tested "All '$prefix' test scripts pass running in a subshell"
}

##
# bash lib tests are the next thing to check. iai cmds depend on it
# TODO WTF are abc.bash tests? stop cowboy coding PLEASE!
# TODO WTF are abc-call_trace.bash tests? stop cowboy coding PLEASE!
# TODO rename bashlib to bashido
run_tests_for "bashlib"

##
# next checkup iai cmd tests, iai interactive cli depends on it
run_tests_for "iaicmd"

# TODO iai interactive commands (cmds that expect stdin interaction)

##
# TODO discovering things to be done: find files cowboy-coded
# TODO discovering things to be done: find TODO comments and display them nicely

cat <<DONE
#################################################
            ! All tests were run !
#################################################
                  good job :D

Now continue with TDD and write more test scripts.
Don't enter cowboy coding mode please!
DONE

##
# vim modeline
# /* vim: set filetype=sh ts=2 shiftwidth=2: */
