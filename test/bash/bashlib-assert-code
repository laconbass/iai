#!/bin/bash

source "$(bashido autotest)" || exit

source "$(bashido assert)" || exit
tested 'bash/assert.bash can be sourced'

# need assert_function to research when functions are declared
type -t "assert_function" >/dev/null
tested 'assert_function is a function'

##
## NOTE: When assertions fail, they should call exit
##       Run assertions inside a subshell to test false positives
##

##
# assert_code checks
assert_function "assert_code"
tested 'assert_code is a function'

# loop over every posible exit code. codes over 255 report a 256 modulo
# see http://www.tldp.org/LDP/abs/html/exitcodes.html
for (( n=0; n <=255; n++ )) do
  # TODO codes over 255
  (exit $n); (assert_code $n)
  tested "after exit $n, assert_code $n reports success"

  prev=$((n-1))
  (exit $prev) ; (assert_code $n) 2>/dev/null && false || true
  tested "after exit $prev, assert_code $n reports failure"

  (exit $prev) ; (assert_code $n) 2>/dev/null
  xcode=$?; expect=$n
  case "$prev" in
    -1) expect=255 ;; # code -1 is invalid exit code, resulting in 255
    256) expect=0  ;; # exit codes over 255 return a 256 modulo
  esac
  test "$xcode" -eq "$expect"
  tested "after exit $prev, assert_code $n returns $expect (actual=$xcode)"
done

##
# assert_returns checks
assert_function "assert_1_returns_2"
tested 'assert_1_returns_2 is a function'

(assert_1_returns_2 'true' 0); tested "true returns 0"
(assert_1_returns_2 'false' 1); tested "false returns 1"
(assert_1_returns_2 'exit' 0); tested "bare exit returns 0"
(assert_1_returns_2 'exit 7' 7); tested "exit 7 returns 7"

(assert_1_returns_2 'true' 1) &>/dev/null && false || true
tested "true returns 1 does not pass assertion"
(assert_1_returns_2 'false' 0) &>/dev/null && false || true
tested "false returns 0 does not pass assertion"
(assert_1_returns_2 'exit 7' 0) &>/dev/null && false || true
tested "exit 7 returns 0 does not pass assertion"


#echo; echo "force failure"; exit 1
