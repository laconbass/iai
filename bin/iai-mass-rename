#!/bin/bash

# TODO esta utilidade pinta ben para un mass-mv

# TODO debug desactivable
debug () { { (( $# )) && echo "$@" || cat ; } >&2 ; }

# TODO more strategies to parse the options
parameters () {
	local total=$# # remember total parameters to calculate positions later
	local parse="" # only short (i.e, -s) and long (i.e, --long) styles
	while [[ "$1" =~ ^--[[:alnum:]]{2,} ]] || [[ "$1" =~ ^-[[:alnum:]]$ ]]
	do
		local param="$1"; shift
		case "$param" in
			--*) parse="opt$param" param=${param:2} ;;
			-?) parse="flag$param; echo \$?" param=${param:1} ;;
		esac
		if test "$(type -t $parse)" == "function"; then
			declare "$param"="$( $parse )"; declare -p $param
			debug "$FUNCNAME: $param set to ${!param}"
		else
			echo >&2 "$FUNCNAME: ignored '$param': '$parse' is not a function"
		fi || { echo >&2 "$FUNCNAME: $param declare returned code $?"; break; }
		# arguments after a single or double dash are considered positional
		[[ "$1" =~ ^[-]{1,2}$ ]] && shift && break
	done
	echo "shift $(( total - $# ))" # how many parameters were shifted
	(( $# ))  # return 0 when there are still parameters
}

debug <<TITLE
###############################################################################
                  Script para renomear arquivos masivamente
###############################################################################
TITLE

# emulates a parameter parsing error
opt--paramerror () { return 1; }

# enables automatic mode (disabled by default)
opt--auto () { echo 1; debug "Modo automático"; }; auto=0
# alias for --auto
flag-a () { opt--auto; }

eval "$(parameters "$@")"

(( auto )) || debug "Estou a traballar en modo interactivo."

CADEA1="${1:-" "}"
CADEA2="${2:-"--"}"


buscar () {
  while read fspath; do
    [[ "$fspath" =~ "$CADEA1" ]] && printf "$fspath\n"
  done < <( find . -path "./.git*" -prune -o "$@" -print)
}

buscar1 () {
  while read fspath; do
    printf "$fspath\n" && return 0
  done < <(buscar "$@")
  return 1
}

count=$(buscar | wc -l)
debug "Atopei $count camiños que conteñen '$CADEA1'."

(( count )) || { debug "Busquei en $(pwd)"; exit 0; }

debug <<INFO
$(buscar -type d | wc -l) directorio/s $(buscar -type f | wc -l) arquivo/s.
Tentarei renomealos todos substituíndo '$CADEA1' por '$CADEA2'."
INFO

moved=0
while fspath="$( buscar1 )"; do
  [[ "$fspath" =~ "$CADEA1" ]] || {
    echo "> erro: 'buscar1' devolveu un path sen '$CADEA1': '$fspath'"
    exit 1
  }
  safepath="${fspath//$CADEA1/$CADEA2}"
  # TODO a way to select `git mv` or `mv`
  # TODO maybe find a way to determine if file is staged or not
  #cmd="git mv -v" # TODO consider -k
  cmd="mv"
  (( auto )) || {
    echo "mover '$fspath'"
    echo "    a '$safepath'"
    echo "Pulsa calquera tecla para mover, ^C para anular"
	read -n 1
  }
  debug "> $cmd \"$fspath\" \"$safepath\""
  $cmd "$fspath" "$safepath" && { (( count++ )); true; } || break
done

debug "> Renomearonse $((count - moved)) dun total de $count camiños."
##
# vim modeline
# /* vim:set filetype=sh ts=4 shiftwidth=4: */
